{"ts":1364067498469,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/*\n * Sample application for Google+ client to server authentication.\n * Remember to fill in the OAuth 2.0 client id and client secret,\n * which can be obtained from the Google Developer Console at\n * https://code.google.com/apis/console\n *\n * Copyright 2013 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nrequire_once __DIR__.'/vendor/autoload.php';\nrequire_once __DIR__.'/google-api-php-client/src/Google_Client.php';\nrequire_once __DIR__.'/google-api-php-client/src/contrib/Google_PlusService.php';\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * Simple server to demonstrate how to use Google+ Sign-In and make a request\n * via your own server.\n *\n * @author silvano@google.com (Silvano Luciani)\n */\n\n/**\n * Replace this with the client ID you got from the Google APIs console.\n */\nconst CLIENT_ID = 'YOUR_CLIENT_ID';\n\n/**\n * Replace this with the client secret you got from the Google APIs console.\n */\nconst CLIENT_SECRET = 'YOUR_CLIENT_SECRET';\n\n/**\n  * Optionally replace this with your application's name.\n  */\nconst APPLICATION_NAME = \"Google+ PHP Quickstart\";\n\n$client = new Google_Client();\n$client->setApplicationName(APPLICATION_NAME);\n$client->setClientId(CLIENT_ID);\n$client->setClientSecret(CLIENT_SECRET);\n$client->setRedirectUri('postmessage');\n\n$plus = new Google_PlusService($client);\n\n$app = new Silex\\Application();\n$app['debug'] = true;\n\n$app->register(new Silex\\Provider\\TwigServiceProvider(), array(\n    'twig.path' => __DIR__,\n));\n$app->register(new Silex\\Provider\\SessionServiceProvider());\n\n// Initialize a session for the current user, and render index.html.\n$app->get('/', function () use ($app) {\n    $state = md5(rand());\n    $app['session']->set('state', $state);\n    return $app['twig']->render('index.html', array(\n        'CLIENT_ID' => CLIENT_ID,\n        'STATE' => $state,\n        'APPLICATION_NAME' => APPLICATION_NAME\n    ));\n});\n\n// Upgrade given auth code to token, and store it in the session.\n// POST body of request should be the authorization code.\n// Example URI: /connect?state=...&gplus_id=...\n$app->post('/connect', function (Request $request) use($app, $client,\n        $oauth2Service) {\n    $token = $app['session']->get('token');\n    if(empty($token)) {\n\n      // Ensure that this is no request forgery going on, and that the user\n      // sending us this connect request is the user that was supposed to.\n      if ($request->get('state') != ($app['session']->get('state'))) {\n        return new Response('Invalid state parameter', 401);\n      }\n      // Normally the state would be a one-time use token, however in our\n      // simple case, we want a user to be able to connect and disconnect\n      // without reloading the page.  Thus, for demonstration, we don't\n      // implement this best practice.\n      //$app['session']->set('state', '');\n\n      $code = $request->getContent();\n      $gPlusId = $request->get['gplus_id'];\n      // Exchange the OAuth 2.0 authorization code for user credentials.\n      $client->authenticate($code);\n\n      $token = json_decode($client->getAccessToken());\n      //verify the token\n      $reqUrl = 'https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=' .\n              $token->access_token;\n      $req = new Google_HttpRequest($reqUrl);\n\n      $tokenInfo = json_decode(\n          $client::getIo()->authenticatedRequest($req)\n              ->getResponseBody());\n\n      // If there was an error in the token info, abort.\n      if ($tokenInfo->error) {\n        return new Response($tokenInfo->error, 401);\n      }\n      // Make sure the token we got is for the intended user.\n      if ($tokenInfo->userid != $gPlusId) {\n        return new Response(\n            'Token\\'s user ID doesn\\'t match given user ID', 401);\n      }\n      // Make sure the token we got is for our app.\n      if ($tokenInfo->audience != CLIENT_ID) {\n        return new Response(\n            'Token\\'s client ID does not match app\\'s.', 401);\n      }\n\n      // Store the token in the session for later use.\n      $app['session']->set('token', json_encode($token));\n      $response = 'Successfully connected with token: ' . print_r($token, true);\n    }\n    return new Response($response, 200);\n});\n\n// Get list of people user has shared with this app.\n$app->get('/people', function () use ($app, $client, $plus) {\n    $token = $app['session']->get('token');\n    if (empty($token)) {\n      return new Response('Unauthorized request', 401);\n    }\n    $client->setAccessToken($token);\n    $people = $plus->people->listPeople('me', 'visible', array());\n    return $app->json($people);\n});\n\n// Revoke current user's token and reset their session.\n$app->post('/disconnect', function () use ($app, $client) {\n  $token = json_decode($app['session']->get('token'))->access_token;\n  $client->revokeToken($token);\n  // Remove the credentials from the user's session.\n  $app['session']->set('token', '');\n  return new Response('Successfully disconnected', 200);\n});\n\n$app->run();\n"]],"start1":0,"start2":0,"length1":0,"length2":5525}]],"length":5525}
{"contributors":[],"silentsave":true,"ts":1364067604757,"patch":[[{"diffs":[[0," = '"],[-1,"YOUR_CLIENT_ID"],[1,"1052328185684.apps.googleusercontent.com"],[0,"';\n\n"]],"start1":1389,"start2":1389,"length1":22,"length2":48}]],"length":5551,"saved":false}
{"ts":1364067619652,"patch":[[{"diffs":[[0," = '"],[-1,"YOUR_CLIENT_SECRET"],[1,"JHYqe2muhIWCfB_smSkUqY4y"],[0,"';\n\n"]],"start1":1541,"start2":1541,"length1":26,"length2":32}]],"length":5557,"saved":false}
{"ts":1364067631612,"patch":[[{"diffs":[[0,"= \"G"],[-1,"oogle+ PHP Quickstart"],[1,"mail App"],[0,"\";\n\n"]],"start1":1663,"start2":1663,"length1":29,"length2":16}]],"length":5544,"saved":false}
{"ts":1364067634473,"patch":[[{"diffs":[[0,"mail App"],[1," SignI"],[0,"\";\n\n$cli"]],"start1":1667,"start2":1667,"length1":16,"length2":22}]],"length":5550,"saved":false}
{"ts":1364067636075,"patch":[[{"diffs":[[0,"p Si"],[-1,"gnI"],[0,"\";\n\n"]],"start1":1674,"start2":1674,"length1":11,"length2":8}]],"length":5547,"saved":false}
{"ts":1364067638568,"patch":[[{"diffs":[[0,"mail App"],[-1," Si"],[0,"\";\n\n$cli"]],"start1":1667,"start2":1667,"length1":19,"length2":16}]],"length":5544,"saved":false}
{"ts":1364067645465,"patch":[[{"diffs":[[0,"mail App"],[1," "],[0,"\";\n\n$cli"]],"start1":1667,"start2":1667,"length1":16,"length2":17}]],"length":5545,"saved":false}
{"ts":1364067648066,"patch":[[{"diffs":[[0,"ail App "],[1,"POC"],[0,"\";\n\n$cli"]],"start1":1668,"start2":1668,"length1":16,"length2":19}]],"length":5548,"saved":false}
{"ts":1364067659937,"patch":[[{"diffs":[[0," App"],[-1," POC"],[1,"l"],[0,"\";\n\n"]],"start1":1671,"start2":1671,"length1":12,"length2":9}]],"length":5545,"saved":false}
{"ts":1364067660943,"patch":[[{"diffs":[[0,"ail Appl"],[1,"ica"],[0,"\";\n\n$cli"]],"start1":1668,"start2":1668,"length1":16,"length2":19}]],"length":5548,"saved":false}
{"ts":1364067662964,"patch":[[{"diffs":[[0," Applica"],[1,"tion"],[0,"\";\n\n$cli"]],"start1":1671,"start2":1671,"length1":16,"length2":20}]],"length":5552,"saved":false}
